--26 Dec 

-- Sub query 와 join은 상호 호환성이 있다. 

-- ******************************************************
-- SELECT 문의 기본구조와 각 절의 실행순서
-- ******************************************************
--  - Clauses -                 - 실행순서 -
--
-- SELECT clause                        (5)
-- FROM clause                          (1)
-- [ WHERE clause ]                     (2)
-- [ GROUP BY clause ]                  (3)
-- [ HAVING clause ]                    (4)
-- [ ORDER BY clause ]                  (6)
-- ******************************************************

-- ------------------------------------------------------
-- 1. Sub-query : 모든 절에 거의 다 사용 가능 (nested SELECT 등) 
-- ------------------------------------------------------
--  가. Join 문:  1 개 이상의 테이블에서, 원하는 데이터를 조회
--  나. sub query는, 하나의 SELECT 문장 만으로 원하는 데이터를 조회할 수 없을 때 사용하는 방법
--  다. 종류:
--      (1) 상관 sub query
--          - 서브쿼리의 단독 수행이 불가능한 경우
--          - 메인쿼리의 데이터가 있어야 실행가능한 경우로,
--          - order : main >> sub query
--          - 메인쿼리의 결과가 서브쿼리에 전달되어, 서브쿼리 수행
--      (2) 비상관 sub query
--          - 서브쿼리의 단독 수행이 가능한 경우로,
--          - order : sub >> main query 
--          - 서브쿼리의 결과가 메인쿼리에 전달되어 실행됨
--  라. 사실상, sub query 는, SELECT 문의 모든 절(clause)
--      에서 뿐만 아니라, 모든 DML문장에서도 사용가능하다!!! (*주의*)
--  마. 반드시** 소괄호()를 사용해야 함.
--  바. 구분: 서브쿼리 실행 후 반환된 행의 개수에 따라,
--      (1) 단일 행 sub query
--          - 서브쿼리 실행 결과가 한 개의 행 반환.
--          - 사용가능 연산자: 비교 연산자 (=, !=, <, >, <=, >=)
--      (2) 복수 행 sub query
--          - 서브쿼리 실행 결과가 복수 개의 행 반환.
--          - 사용가능 연산자: IN, ANY, ALL, EXIST 등
--  사.  **가장 주의할 점**: 사용할 연산자
--      사용된 연산자에 따라, 위 '아'와 같이 행 반환
-- ------------------------------------------------------
-- Basic Syntax)
--
-- SELECT select_list       -- main query(바깥쪽 SELECT 문장)
-- FROM 테이블
-- WHERE 컬럼명 연산자 (
--  SELECT select_list FROM 테이블    -- sub query(안쪽 SELECT 문장)
-- );
-- ------------------------------------------------------
-- * Please refer to the chapter 06, page 2.
-- ------------------------------------------------------

-- ------------------------------------------------------
-- 사원정보에서, 'Whalen'보다 많은 월급을 받는 사원조회 #1
-- ------------------------------------------------------
-- * 하나의 SELECT문장만으로는 조회불가:
--  가. 먼저, 'Whalen'의 월급이 얼마나인지 알아야 함. (SELECT 1)
--  나. 조회한 'Whalen'의 월급보다 많은 월급을 받는 사원조회가능 (SELECT 2)
-- ------------------------------------------------------


SELECT salary
FROM employees
WHERE last_name = 'Whalen';

-- SELECT 2: Whalen 보다 월급을 많이 받는 사원 조회
SELECT last_name, salary
FROM employees
WHERE salary >= 4400;   -- Whalen의 월급지정


-- ------------------------------------------------------
-- 사원정보에서, 'Whalen'보다 많은 월급을 받는 사원조회 , Whalen 제외 #2
-- ------------------------------------------------------
-- 위 #1과 같이, 하나 이상의 SELECT 문장이 있어야만, 원하는 결과
-- 를 조회가능한 경우에, 서브쿼리(=부속질의) 사용가능.
--
-- 즉, 서브쿼리는, 여러 번의 SELECT 문장을 수행해야 얻을 수 있는
-- 결과를, 하나의 중첩된(nested) SELECT 문장으로 만들어, 원하는
-- 결과를 쉽게 조회가능하게 함.
-- ------------------------------------------------------

SELECT  
    (--그냥 first_name, 이 한 문장을 풀어 쓴 거
        SELECT t.first_name 
        FROM employees t --  alias를 한번 사용하면 생략하지마라
        Where t.employee_id = m.employee_id -- 구분을 위해 alias 사용
    ) AS first_name,
    last_name,
    salary
FROM
    (
        SELECT * 
        FROM 
            employees 
        WHERE 
            last_name != 'Whalen'
    ) m -- table alias
WHERE
    salary >= (
        -- Whalen의 월급여가 메인쿼리에 전달됨
        SELECT salary
        FROM employees
        WHERE last_name = 'Whalen'
    );

-- ------------------------------------------------------
-- 2. 단일 행 Sub-query
-- ------------------------------------------------------
-- 가. 하나의 행을 반환
-- 나. 반드시 단일 행 서브쿼리를 사용해야만 하는 경우:
--      - 기본키(Primary Key)를 이용하는 경우
--      - 그룹함수(MAX, MIN, SUM 등)를 이용하는 경우
-- ------------------------------------------------------
-- * Please refer to the chapter 06, page 6.
-- ------------------------------------------------------

-- ------------------------------------------------------
-- (1) 평균 월급여보다 많은 월급을 받는 사원조회
-- ------------------------------------------------------
-- 평균 급여를 먼저 구하기 위해, 단일 행 서브쿼리 및 그룹함수 AVG 사용
-- 따라서, 메인쿼리 사용가능한 연산자 : 비교연산자!
-- vector 
-- schalar : 한개의 행 한개의 값

SELECT
    last_name,
    salary
FROM
    employees
WHERE
    -- 메인쿼리: 단일행 서브쿼리가 사용되었으므로, 단일 값과 비교가능한
    --          비교연산자 사용가능
    salary >= ( 
        -- 단일행 비상관(독립수행) sub query: 모든 사원의 평균 월급여 반환
        SELECT avg(salary) -- 하나의 값만 return
        FROM employees
    );


-- ------------------------------------------------------
-- (2) 100번 부서의 최대 월급여와 동일한 월급을 받는 사원조회
-- ------------------------------------------------------

SELECT
    last_name,
    salary
FROM
    employees
WHERE
    -- 메인쿼리: 단일행 서브쿼리가 사용되었으므로, 단일 값과 비교가능한
    --          비교연산자 사용가능
    salary = (
        -- 단일 행 비상관 서브쿼리: 100번 부서의 최대 월급여 반환
        -- schalar값을 한번 생성하면 다시 할필요 없음 . 마치 literal같이 .
        -- 메인쿼리로 결과값 전달
        SELECT max(salary)
        FROM employees
        WHERE department_id = 100
    );


-- ------------------------------------------------------
-- (3) 100번 부서의 최대 월급여보다, 많은 월급을 받는 부서조회
-- ------------------------------------------------------
SELECT
    -- 최종적으로 선택된, 각 부서의 번호와 최소 월급여 출력
    department_id,
    min(salary)
FROM
    employees
GROUP BY
    -- 부서별 그룹 생성
    department_id
HAVING
    -- 메인쿼리 2차 필터링: 조건에 부합하는 그룹만 필터링
    -- 단일행 서브쿼리가 사용되었으므로, 단일 값과 비교가능한 비교연산자 사용가능
    min(salary) > (
        -- 단일 행 비상관 서브쿼리: 100번 부서의 최대 월급여 반환
        -- 메인쿼리로 결과값 전달
        SELECT max(salary)
        FROM employees
        WHERE department_id = 100
    );


-- ------------------------------------------------------
-- (4) 사원 Whalen 보다, 채용일자가 느린 사원조회
-- ------------------------------------------------------

SELECT
    last_name,
    hire_date
FROM
    employees
WHERE
    -- 메인쿼리 1차 필터링: 단일행 서브쿼리가 사용되었으므로, 
    -- 단일 값과 비교가능한 비교연산자 사용가능
    hire_date > (
        -- 단일 행 비상관 서브쿼리: Whalen의 채용일자 반환
        -- 메인쿼리로 결과값 전달
        SELECT hire_date
        FROM employees
        WHERE last_name = 'Whalen'
    );